---
title: "quefts"
author: "Robert J. Hijmans"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to RQuefts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


This vignette illustrates the use of the `RQuefts` package. The package provides a R interface to a C++ implentation of the model. QUEFTS is a simple and elegant model that can estimate the amount of fertilizer needed to reach a particular crop yield; or to estimate the crop yield given the amount of fertilizer applied. To run the model, you need soil and crop parameters, as well as the amount of fertilizer applied, and the attainable biomass production. In this context, that is the maximum production in the absence of nutrient limitation, or the target biomass production. 


## Create and run a model


The first step is to create a model. You can create a model with default parameters like this,

```{r} 
library(Rquefts)
q <- quefts()
```

And then run the model

```{r} 
run(q)
```

You can also initialize a model with parameters of you choice

```{r} 
soiltype <- quefts_soil()
barley <- quefts_crop('Barley')
fertilizer <- list(N=50, P=0, K=0)
biomass <- list(leaf_att=2200, stem_att=2700, store_att=4800, SeasonLength=110)
q <- quefts(soiltype, barley, fertilizer, biomass)
```



## Callibration

Here I illustrate some basic approaches that can be used for callibration. 
First I generate some data. 

```{r} 
set.seed(99)
yldfun <- function(N, noise=TRUE) { 1000 +  500* log(N+1)/3 + noise * runif(length(N), -500, 500) }
N <- seq(0,300,25)
Y <- replicate(10, yldfun(N))
obs <- cbind(N, Y)
```

We will use Root Mean Square Error (RMSE) to assess model fit. 

```{r} 
RMSE <- function(obs, pred) sqrt(mean((obs - pred)^2))
```

Let's see how good the default parameters work for us.

```{r} 
q <- quefts()
q$P <- 0
q$K <- 0

results <- matrix(nrow=length(N), ncol=12)
colnames(results) <- names(run(q))
for (i in 1:length(N)) {
	q$N <- N[i]
	results[i,] <- run(q)
}

yield <- results[,'store_lim']
RMSE(obs[,-1], yield)
```

The RMSE is quite high. 

Create a function to minimize with the optimizer. Here I try to improve the model by altering four parameters.

```{r} 

vars <- c('soil$N_base_supply', 'soil$N_recovery', 'crop$NminStore', 'crop$NmaxStore')

f <- function(p) {
	if (any (p < 0)) return(Inf)
	if (p['crop$NminStore'] >= p['crop$NmaxStore']) return(Inf)
	if (p['soil$N_recovery'] > .6 | p['soil$N_recovery'] < .3) return(Inf)
	q[names(p)] <- p
	pred <- run(q)
	RMSE(obs[,-1], pred['store_lim'])
}

# try the function with some initial values
x <- c(50, 0.5,  0.011, 0.035)
names(x) <- vars
f(x)
```

Now optimize

```{r} 
par <- optim(x, f)
# RMSE
par$value
# optimal parameters
par$par
```

